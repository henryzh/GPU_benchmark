Odin II - Version 0.2 - Quick Start

In the DOCUMENTATION directory there is more thorough details about
Odin II.  This is a quick start guide.

INSTALL
------------

1. LIBVPR

This library needs to be built for your platform.  The Makefile for
Odin will link the LIBVPR library located in:
../libvpr_5 or ../libvpr_6

By default Odin II uses libvpr_6. To compile it, change directory to 
../libvpr_6 and type "make". 

Note: 
- for WIN32 compilation you'll have to edit the ezxml.c files
to "#define WIN32" or not.

2. Odin II

Odin is compiled with a standard Makefile.  For the first time
I would suggest a:
make clean && make

Note: 
- that Odin relies on ctags, bison, and flex.  These details are not 
included in this install and are left to the user. (On linux systems, 
these packages are generally available through your distribution's package 
management system.)
- the default make targets VRP 6.0. For VPR 5.0 you can either
change the Makefile variable "BUILD=" to VPR5 or you can type:
make clean && make BUILD=VPR5

USAGE
-------------

After you build Odin, please run the included verify_microbenchmarks.sh 
script. This will automatically compile, simulate, and verify all of the
included microbenchmark circuits to ensure that Odin is working 
correctly on your system. 

To use Odin II, invoke it from the command line as ./odin_II.exe.
./odin_II.exe -h will give you a list of the possible options. Commonly 
used options are -V to supply a verilog file to compile, -a to supply 
an FPGA arch file to map to, and -o to supply a blif output filename. 

You can specify a configuration file with the -c
option, as it ./odin_II.exe -c config.xml. A config file looks
like the following:
<config>
	<verilog_files>
		<!-- Way of specifying multiple files in a project -->
		<verilog_file>verilog_file.v</verilog_file>
	</verilog_files>
	<output>
		<!-- These are the output flags for the project -->
		<output_type>blif</output_type>
		<output_path_and_name>./output_file.blif</output_path_and_name>
		<target>
			<!-- This is the target device the output is being built for -->
			<arch_file>fpga_architecture_file.xml</arch_file>
		</target>
	</output>
	<optimizations>
		<!-- This is where the optimization flags go -->
	</optimizations>
	<debug_outputs>
		<!-- Various debug options -->
		<debug_output_path>.</debug_output_path>
		<output_ast_graphs>1</output_ast_graphs>
		<output_netlist_graphs>1</output_netlist_graphs>
	</debug_outputs>
</config>

You may specify multiple verilog files for synthesis. The 
fpga_architecture_file.xml format is specified from VPR. output_ast_graphs set 
to 1 will give you abstract syntax tree graphs which can be viewed using 
GraphViz. The output_netliet_graphs does the same, except it visualizes the
netlist synthesized by Odin II.

The -g x flag will simulate the generated netlist with x clock cycles using 
pseudo-random test vectors. These vectors and the resulting output vectors are
written to "input_vectors" and "output_vectors" respectively. You can supply 
a predefined input vector file by replacing the -g option with the -t option. 
The output vectors can also be verified against a predefined output vector 
file via the -T option. 

A test vector file is as follows:
# Example vector file
intput_1 input_2 output_1 output_2 output_3
# Comment 
0 0XA 1 0XD 1101
-------------

Each line represents a vector. Each value must be specified in binary or hex. 
Comments may be included by placing an # at the start of the line. Blank lines 
are ignored. Values may be separated by non-newline whitespace. (tabs and spaces)
Hex values must be prefixed with 0X. 

Each line in the vector file represents one cycle, or one falling edge and one 
rising edge. Input vectors are read on a falling edge, while output vectors are 
written on a rising edge. 

Hard blocks can be simulated; given a hardblock named "block" in the 
architecture file with an instance of it named "instance" in the verilog file,
write a C method with signature defined in SRC/sim_block.h and compile it with
an output filename of "block+instance.so" in the directory you plan to invoke 
Odin-II from. When compiling the file, you'll need to specify the following 
arguments to the compiler (assuming that you're in the SANBOX directory):
"`cc -I../../libvpr_6/include/ -L../../libvpr_6 -lvpr_6 -lm --shared -o 
block+instance.so block.c". When compiling against VPR5, adjust the arguments
accordingly. 

If the netlist generated by Odin II contains the definition of a hardblock which
doesn't have a shared object file defined for it in the working directory,
Odin II will not work if you specify it to use the simulator with the -g or -t
options.

Use of static memory within the simulation code necessitates compiling a 
distinct shared object file for each instance of the block you wish to simulate.
The method signature the simulator expects contains only int and int[] 
parameters, leaving the code provided to simulate the hard blokc agnostic of the
internal Odin II data structures. However, a cycle parameter is included to 
provide researchers with the ability to delay results of operations performed by
the simulation code.

CONTACT
-------------

jamieson dot peter at gmail dot com
ken at unb dot ca
- We will service all requests as timely as possible, but
please explain the problem with enough detail to help. 
